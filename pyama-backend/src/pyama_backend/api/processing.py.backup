"""Processing API endpoints."""

import logging
import os
from pathlib import Path
from typing import Optional

from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel, Field

from pyama_core.io import MicroscopyMetadata, load_microscopy_file

logger = logging.getLogger(__name__)

router = APIRouter()


# =============================================================================
# REQUEST/RESPONSE MODELS
# =============================================================================


class LoadMetadataRequest(BaseModel):
    """Request model for loading microscopy metadata."""

    file_path: str = Field(..., description="Path to microscopy file (ND2 or CZI)")


class MicroscopyMetadataResponse(BaseModel):
    """Response model for microscopy metadata."""

    file_path: str
    base_name: str
    file_type: str
    height: int
    width: int
    n_frames: int
    n_fovs: int
    n_channels: int
    timepoints: list[float]
    channel_names: list[str]
    dtype: str

    @classmethod
    def from_metadata(cls, metadata: MicroscopyMetadata) -> "MicroscopyMetadataResponse":
        """Create response from MicroscopyMetadata."""
        return cls(
            file_path=str(metadata.file_path),
            base_name=metadata.base_name,
            file_type=metadata.file_type,
            height=metadata.height,
            width=metadata.width,
            n_frames=metadata.n_frames,
            n_fovs=metadata.n_fovs,
            n_channels=metadata.n_channels,
            timepoints=metadata.timepoints,
            channel_names=metadata.channel_names,
            dtype=metadata.dtype,
        )


class LoadMetadataResponse(BaseModel):
    """Response model for load metadata endpoint."""

    success: bool
    metadata: MicroscopyMetadataResponse | None = None
    error: str | None = None


# =============================================================================
# FILE EXPLORER MODELS
# =============================================================================


class FileItem(BaseModel):
    """Model for a file or directory item."""

    name: str
    path: str
    is_directory: bool
    is_file: bool
    size_bytes: Optional[int] = None
    modified_time: Optional[str] = None
    extension: Optional[str] = None


class DirectoryListingRequest(BaseModel):
    """Request model for listing directory contents."""

    directory_path: str = Field(..., description="Path to directory to list")
    include_hidden: bool = Field(False, description="Include hidden files and directories")
    filter_extensions: Optional[list[str]] = Field(None, description="Filter by file extensions (e.g., ['.nd2', '.czi'])")


class DirectoryListingResponse(BaseModel):
    """Response model for directory listing."""

    success: bool
    directory_path: str
    items: list[FileItem] = []
    error: str | None = None


class SearchFilesRequest(BaseModel):
    """Request model for searching files."""

    search_path: str = Field(..., description="Root directory to search from")
    pattern: Optional[str] = Field(None, description="Search pattern (glob pattern)")
    extensions: Optional[list[str]] = Field(None, description="File extensions to search for")
    max_depth: int = Field(10, description="Maximum search depth")
    include_hidden: bool = Field(False, description="Include hidden files and directories")


class SearchFilesResponse(BaseModel):
    """Response model for file search."""

    success: bool
    search_path: str
    files: list[FileItem] = []
    total_found: int = 0
    error: str | None = None


class FileInfoRequest(BaseModel):
    """Request model for getting file information."""

    file_path: str = Field(..., description="Path to file")


class FileInfoResponse(BaseModel):
    """Response model for file information."""

    success: bool
    file_info: Optional[FileItem] = None
    is_microscopy_file: bool = False
    metadata_preview: Optional[MicroscopyMetadataResponse] = None
    error: str | None = None


# =============================================================================
# ENDPOINTS
# =============================================================================


@router.post("/load-metadata", response_model=LoadMetadataResponse)
async def load_metadata(request: LoadMetadataRequest) -> LoadMetadataResponse:
    """Load metadata from a microscopy file (ND2 or CZI format).

    Args:
        request: Request containing file path

    Returns:
        Response with metadata or error message
    """
    file_path = Path(request.file_path)

    # Validate file exists
    if not file_path.exists():
        logger.error("File not found: %s", file_path)
        return LoadMetadataResponse(
            success=False,
            error=f"File not found: {file_path}",
        )

    # Validate file extension
    if file_path.suffix.lower() not in [".nd2", ".czi"]:
        logger.error("Unsupported file type: %s", file_path.suffix)
        return LoadMetadataResponse(
            success=False,
            error=f"Unsupported file type: {file_path.suffix}. Supported types: .nd2, .czi",
        )

    try:
        # Load microscopy file
        logger.info("Loading microscopy file: %s", file_path)
        _, metadata = load_microscopy_file(file_path)

        # Convert to response model
        metadata_response = MicroscopyMetadataResponse.from_metadata(metadata)

        logger.info(
            "Successfully loaded metadata: %d channels, %d FOVs, %d frames",
            metadata.n_channels,
            metadata.n_fovs,
            metadata.n_frames,
        )

        return LoadMetadataResponse(
            success=True,
            metadata=metadata_response,
        )

    except Exception as e:
        logger.exception("Failed to load microscopy file: %s", file_path)
        return LoadMetadataResponse(
            success=False,
            error=f"Failed to load file: {str(e)}",
        )


# =============================================================================
# FILE EXPLORER ENDPOINTS
# =============================================================================


@router.post("/list-directory", response_model=DirectoryListingResponse)
async def list_directory(request: DirectoryListingRequest) -> DirectoryListingResponse:
    """List contents of a directory with optional filtering.
    
    Args:
        request: Request containing directory path and filtering options
        
    Returns:
        Response with directory contents or error message
    """
    directory_path = Path(request.directory_path)
    
    # Validate directory exists
    if not directory_path.exists():
        logger.error("Directory not found: %s", directory_path)
        return DirectoryListingResponse(
            success=False,
            directory_path=str(directory_path),
            error=f"Directory not found: {directory_path}",
        )
    
    if not directory_path.is_dir():
        logger.error("Path is not a directory: %s", directory_path)
        return DirectoryListingResponse(
            success=False,
            directory_path=str(directory_path),
            error=f"Path is not a directory: {directory_path}",
        )
    
    try:
        items = []
        
        # Get directory contents
        for item_path in directory_path.iterdir():
            # Skip hidden files if not requested
            if not request.include_hidden and item_path.name.startswith('.'):
                continue
            
            # Check if it's a file or directory
            is_file = item_path.is_file()
            is_directory = item_path.is_dir()
            
            # Skip if not file or directory (e.g., symlinks, etc.)
            if not (is_file or is_directory):
                continue
            
            # Apply extension filter for files
            if is_file and request.filter_extensions:
                if item_path.suffix.lower() not in [ext.lower() for ext in request.filter_extensions]:
                    continue
            
            # Get file size for files
            size_bytes = None
            if is_file:
                try:
                    size_bytes = item_path.stat().st_size
                except OSError:
                    size_bytes = None
            
            # Get modification time
            modified_time = None
            try:
                modified_time = item_path.stat().st_mtime
                modified_time = str(modified_time)  # Convert to string for JSON serialization
            except OSError:
                modified_time = None
            
            # Get file extension
            extension = item_path.suffix if is_file else None
            
            items.append(FileItem(
                name=item_path.name,
                path=str(item_path),
                is_directory=is_directory,
                is_file=is_file,
                size_bytes=size_bytes,
                modified_time=modified_time,
                extension=extension,
            ))
        
        # Sort items: directories first, then files, both alphabetically
        items.sort(key=lambda x: (not x.is_directory, x.name.lower()))
        
        logger.info("Listed directory %s: %d items", directory_path, len(items))
        
        return DirectoryListingResponse(
            success=True,
            directory_path=str(directory_path),
            items=items,
        )
        
    except PermissionError:
        logger.error("Permission denied accessing directory: %s", directory_path)
        return DirectoryListingResponse(
            success=False,
            directory_path=str(directory_path),
            error=f"Permission denied accessing directory: {directory_path}",
        )
    except Exception as e:
        logger.exception("Failed to list directory: %s", directory_path)
        return DirectoryListingResponse(
            success=False,
            directory_path=str(directory_path),
            error=f"Failed to list directory: {str(e)}",
        )


@router.post("/search-files", response_model=SearchFilesResponse)
async def search_files(request: SearchFilesRequest) -> SearchFilesResponse:
    """Search for files recursively with optional pattern matching.
    
    Args:
        request: Request containing search parameters
        
    Returns:
        Response with found files or error message
    """
    search_path = Path(request.search_path)
    
    # Validate search path exists
    if not search_path.exists():
        logger.error("Search path not found: %s", search_path)
        return SearchFilesResponse(
            success=False,
            search_path=str(search_path),
            error=f"Search path not found: {search_path}",
        )
    
    if not search_path.is_dir():
        logger.error("Search path is not a directory: %s", search_path)
        return SearchFilesResponse(
            success=False,
            search_path=str(search_path),
            error=f"Search path is not a directory: {search_path}",
        )
    
    try:
        files = []
        
        # Build glob pattern
        if request.pattern:
            pattern = request.pattern
        else:
            # Default pattern for microscopy files
            if request.extensions:
                ext_pattern = "{" + ",".join(request.extensions) + "}"
                pattern = f"**/*{ext_pattern}"
            else:
                pattern = "**/*.{nd2,czi}"
        
        # Search for files
        for file_path in search_path.glob(pattern):
            # Skip if not a file
            if not file_path.is_file():
                continue
            
            # Skip hidden files if not requested
            if not request.include_hidden and file_path.name.startswith('.'):
                continue
            
            # Check depth limit
            try:
                depth = len(file_path.relative_to(search_path).parts) - 1
                if depth > request.max_depth:
                    continue
            except ValueError:
                # File is not relative to search path, skip
                continue
            
            # Get file size
            size_bytes = None
            try:
                size_bytes = file_path.stat().st_size
            except OSError:
                size_bytes = None
            
            # Get modification time
            modified_time = None
            try:
                modified_time = file_path.stat().st_mtime
                modified_time = str(modified_time)
            except OSError:
                modified_time = None
            
            files.append(FileItem(
                name=file_path.name,
                path=str(file_path),
                is_directory=False,
                is_file=True,
                size_bytes=size_bytes,
                modified_time=modified_time,
                extension=file_path.suffix,
            ))
        
        # Sort files by name
        files.sort(key=lambda x: x.name.lower())
        
        logger.info("Search completed in %s: %d files found", search_path, len(files))
        
        return SearchFilesResponse(
            success=True,
            search_path=str(search_path),
            files=files,
            total_found=len(files),
        )
        
    except PermissionError:
        logger.error("Permission denied searching directory: %s", search_path)
        return SearchFilesResponse(
            success=False,
            search_path=str(search_path),
            error=f"Permission denied searching directory: {search_path}",
        )
    except Exception as e:
        logger.exception("Failed to search files: %s", search_path)
        return SearchFilesResponse(
            success=False,
            search_path=str(search_path),
            error=f"Failed to search files: {str(e)}",
        )


@router.post("/file-info", response_model=FileInfoResponse)
async def get_file_info(request: FileInfoRequest) -> FileInfoResponse:
    """Get detailed information about a file, including metadata preview for microscopy files.
    
    Args:
        request: Request containing file path
        
    Returns:
        Response with file information and optional metadata preview
    """
    file_path = Path(request.file_path)
    
    # Validate file exists
    if not file_path.exists():
        logger.error("File not found: %s", file_path)
        return FileInfoResponse(
            success=False,
            error=f"File not found: {file_path}",
        )
    
    if not file_path.is_file():
        logger.error("Path is not a file: %s", file_path)
        return FileInfoResponse(
            success=False,
            error=f"Path is not a file: {file_path}",
        )
    
    try:
        # Get basic file information
        stat = file_path.stat()
        
        file_info = FileItem(
            name=file_path.name,
            path=str(file_path),
            is_directory=False,
            is_file=True,
            size_bytes=stat.st_size,
            modified_time=str(stat.st_mtime),
            extension=file_path.suffix,
        )
        
        # Check if it's a microscopy file
        is_microscopy_file = file_path.suffix.lower() in ['.nd2', '.czi']
        
        # Load metadata preview for microscopy files
        metadata_preview = None
        if is_microscopy_file:
            try:
                logger.info("Loading metadata preview for: %s", file_path)
                _, metadata = load_microscopy_file(file_path)
                metadata_preview = MicroscopyMetadataResponse.from_metadata(metadata)
                logger.info("Successfully loaded metadata preview for: %s", file_path)
            except Exception as e:
                logger.warning("Failed to load metadata preview for %s: %s", file_path, e)
                # Don't fail the entire request if metadata loading fails
                metadata_preview = None
        
        logger.info("Retrieved file info for: %s", file_path)
        
        return FileInfoResponse(
            success=True,
            file_info=file_info,
            is_microscopy_file=is_microscopy_file,
            metadata_preview=metadata_preview,
        )
        
    except PermissionError:
        logger.error("Permission denied accessing file: %s", file_path)
        return FileInfoResponse(
            success=False,
            error=f"Permission denied accessing file: {file_path}",
        )
    except Exception as e:
        logger.exception("Failed to get file info: %s", file_path)
        return FileInfoResponse(
            success=False,
            error=f"Failed to get file info: {str(e)}",
        )


@router.get("/recent-files")
async def get_recent_files(
    limit: int = Query(10, description="Maximum number of recent files to return"),
    extensions: Optional[str] = Query(None, description="Comma-separated list of extensions to filter by")
) -> dict:
    """Get recently accessed microscopy files.
    
    This is a simplified implementation that returns an empty list.
    In a production system, you might want to track file access history.
    
    Args:
        limit: Maximum number of files to return
        extensions: Optional comma-separated list of extensions to filter by
        
    Returns:
        Response with recent files list
    """
    # For now, return empty list
    # In a real implementation, you might track file access in a database
    # or use system file access logs
    
    logger.info("Requested recent files (limit=%d, extensions=%s)", limit, extensions)
    
    return {
        "success": True,
        "recent_files": [],
        "message": "Recent files tracking not implemented yet"
    }
